<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_31) on Fri Jun 22 13:52:16 EDT 2012 -->
<TITLE>
JPacket
</TITLE>

<META NAME="date" CONTENT="2012-06-22">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="JPacket";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/jnetpcap/packet/JMemoryPacket.JMemoryHeader.html" title="class in org.jnetpcap.packet"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/jnetpcap/packet/JPacket.State.html" title="class in org.jnetpcap.packet"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/jnetpcap/packet/JPacket.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="JPacket.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.jnetpcap.packet</FONT>
<BR>
Class JPacket</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><A HREF="../../../org/jnetpcap/nio/JMemory.html" title="class in org.jnetpcap.nio">org.jnetpcap.nio.JMemory</A>
      <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><A HREF="../../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio">org.jnetpcap.nio.JBuffer</A>
          <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>org.jnetpcap.packet.JPacket</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.lang.Iterable&lt;<A HREF="../../../org/jnetpcap/packet/JHeader.html" title="class in org.jnetpcap.packet">JHeader</A>&gt;, <A HREF="../../../org/jnetpcap/packet/JHeaderAccessor.html" title="interface in org.jnetpcap.packet">JHeaderAccessor</A></DD>
</DL>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../../org/jnetpcap/packet/JMemoryPacket.html" title="class in org.jnetpcap.packet">JMemoryPacket</A>, <A HREF="../../../org/jnetpcap/packet/PcapPacket.html" title="class in org.jnetpcap.packet">PcapPacket</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public abstract class <B>JPacket</B><DT>extends <A HREF="../../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</A><DT>implements <A HREF="../../../org/jnetpcap/packet/JHeaderAccessor.html" title="interface in org.jnetpcap.packet">JHeaderAccessor</A>, java.lang.Iterable&lt;<A HREF="../../../org/jnetpcap/packet/JHeader.html" title="class in org.jnetpcap.packet">JHeader</A>&gt;</DL>
</PRE>

<P>
A native packet buffer object. This class references both packet data buffer
 and decoded native packet structure. JPacket class is a subclass of a more
 general JBuffer providing full access to raw packet buffer data. It also has
 a reference to JPacket.State object which is peered, associated with, a
 native packet state structure generated by the packet scanner, the JScanner.
 <p>
 The packet interface provides numerous methods for accessing the decoded
 information. To check if any particular header is found within the packet's
 data buffer at the time the packet was scanned, the user can use
 <A HREF="../../../org/jnetpcap/packet/JPacket.html#hasHeader(int)"><CODE>hasHeader(int)</CODE></A> methods. The method returns true if a particular header is
 found within the packet data buffer, otherwise false. A convenience method
 <A HREF="../../../org/jnetpcap/packet/JPacket.html#hasHeader(T)"><CODE>hasHeader(JHeader)</CODE></A> exists that performs both an existance check and
 initializes the header instace supplied to point at the header within the
 packet.
 </p>
 <p>
 There are also numerous peer and deep copy methods. The peering methods do
 not copy any buffers but simply re-orient the pointers to point at the source
 peer structures to destination peer. The deep copy methods do copy physical
 data out of buffers and entire structures using native copy functions, not in
 java space.
 </p>
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>Mark Bednarczyk, Sly Technologies, Inc.</DD>
</DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.State.html" title="class in org.jnetpcap.packet">JPacket.State</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Class maintains the decoded packet state.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="nested_classes_inherited_from_class_org.jnetpcap.nio.JMemory"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Nested classes/interfaces inherited from class org.jnetpcap.nio.<A HREF="../../../org/jnetpcap/nio/JMemory.html" title="class in org.jnetpcap.nio">JMemory</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../org/jnetpcap/nio/JMemory.Type.html" title="enum in org.jnetpcap.nio">JMemory.Type</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#DEFAULT_STATE_HEADER_COUNT">DEFAULT_STATE_HEADER_COUNT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default number of headers used when calculating memory requirements for
 an empty packet state structure.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;<A HREF="../../../org/jnetpcap/packet/JScanner.html" title="class in org.jnetpcap.packet">JScanner</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#defaultScanner">defaultScanner</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default scanner used to scan a packet per user request.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#memory">memory</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The allocated memory buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;<A HREF="../../../org/jnetpcap/nio/JMemoryPool.html" title="class in org.jnetpcap.nio">JMemoryPool</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#pool">pool</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packet's default memory pool out of which allocates memory for deep
 copies.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../org/jnetpcap/packet/JPacket.State.html" title="class in org.jnetpcap.packet">JPacket.State</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#state">state</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packet's state structure.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_org.jnetpcap.nio.JMemory"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Fields inherited from class org.jnetpcap.nio.<A HREF="../../../org/jnetpcap/nio/JMemory.html" title="class in org.jnetpcap.nio">JMemory</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../org/jnetpcap/nio/JMemory.html#JNETPCAP_LIBRARY_NAME">JNETPCAP_LIBRARY_NAME</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#MAX_DIRECT_MEMORY_DEFAULT">MAX_DIRECT_MEMORY_DEFAULT</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#POINTER">POINTER</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#JPacket(int, int)">JPacket</A></B>(int&nbsp;size,
        int&nbsp;state)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocates a memory block and peers both the state and data buffer with
 it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#JPacket(org.jnetpcap.nio.JMemory.Type)">JPacket</A></B>(<A HREF="../../../org/jnetpcap/nio/JMemory.Type.html" title="enum in org.jnetpcap.nio">JMemory.Type</A>&nbsp;type)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A JPacket pointer.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#allocate(int)">allocate</A></B>(int&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new memory buffer of given size for internal usage.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; java.lang.Iterable&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#filterByType(java.lang.Class)">filterByType</A></B>(java.lang.Class&lt;T&gt;&nbsp;type)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Filter existing header instances by specified type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#getAllocatedMemorySize()">getAllocatedMemorySize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the size of the current internal memory buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../org/jnetpcap/JCaptureHeader.html" title="interface in org.jnetpcap">JCaptureHeader</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#getCaptureHeader()">getCaptureHeader</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the capture header as generated by the native capture library.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/jnetpcap/packet/JHeaderPool.html" title="class in org.jnetpcap.packet">JHeaderPool</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#getDefaultHeaderPool()">getDefaultHeaderPool</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the default header pool.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/jnetpcap/packet/JScanner.html" title="class in org.jnetpcap.packet">JScanner</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#getDefaultScanner()">getDefaultScanner</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the default scanner for all packets</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/jnetpcap/packet/JFlowKey.html" title="class in org.jnetpcap.packet">JFlowKey</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#getFlowKey()">getFlowKey</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the unique flow-key for this packet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/jnetpcap/packet/JFlowKey.html" title="class in org.jnetpcap.packet">JFlowKey</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#getFlowKey(org.jnetpcap.packet.JFlowKey)">getFlowKey</A></B>(<A HREF="../../../org/jnetpcap/packet/JFlowKey.html" title="class in org.jnetpcap.packet">JFlowKey</A>&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the unique flow-key for this packet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/jnetpcap/packet/format/JFormatter.html" title="class in org.jnetpcap.packet.format">JFormatter</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#getFormatter()">getFormatter</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the current internal packet formatter used in the <A HREF="../../../org/jnetpcap/packet/JPacket.html#toString()"><CODE>toString()</CODE></A>
 method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#getFrameNumber()">getFrameNumber</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the frame number as assigned by either the packet scanner or
 analyzers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends <A HREF="../../../org/jnetpcap/packet/JHeader.html" title="class in org.jnetpcap.packet">JHeader</A>&gt; 
<BR>
T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#getHeader(T)">getHeader</A></B>(T&nbsp;header)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Peers the supplied header with the native header state structure and
 packet data buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends <A HREF="../../../org/jnetpcap/packet/JHeader.html" title="class in org.jnetpcap.packet">JHeader</A>&gt; 
<BR>
T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#getHeader(T, int)">getHeader</A></B>(T&nbsp;header,
          int&nbsp;instance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Peers the supplied header with the native header state structure and
 packet data buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends <A HREF="../../../org/jnetpcap/packet/JHeader.html" title="class in org.jnetpcap.packet">JHeader</A>&gt; 
<BR>
T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#getHeaderByIndex(int, T)">getHeaderByIndex</A></B>(int&nbsp;index,
                 T&nbsp;header)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Peers a header with specific index, not the numerical header ID assigned
 by JRegistry, of a header.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#getHeaderCount()">getHeaderCount</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets number of headers found within the packet header.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#getHeaderIdByIndex(int)">getHeaderIdByIndex</A></B>(int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the numerical ID of the header at specified index into header array
 as found by the packet scanner.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#getHeaderInstanceCount(int)">getHeaderInstanceCount</A></B>(int&nbsp;id)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets number of headers with the same numerical ID as assigned by
 JRegistry within the same packet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#getMemoryBuffer(byte[])">getMemoryBuffer</A></B>(byte[]&nbsp;buffer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the memory buffer with the supplied byte array data copied into it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#getMemoryBuffer(java.nio.ByteBuffer)">getMemoryBuffer</A></B>(java.nio.ByteBuffer&nbsp;buffer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the memory buffer with the supplied ByteBuffer data copied into it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#getMemoryBuffer(int)">getMemoryBuffer</A></B>(int&nbsp;minSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves a memory buffer, allocated if neccessary, at least minSize in
 bytes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#getMemoryBuffer(org.jnetpcap.nio.JBuffer)">getMemoryBuffer</A></B>(<A HREF="../../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</A>&nbsp;buffer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the memory buffer with the supplied JBuffer data copied into it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/jnetpcap/nio/JMemoryPool.html" title="class in org.jnetpcap.nio">JMemoryPool</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#getMemoryPool()">getMemoryPool</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the current memory allocation memory pool.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#getPacketWirelen()">getPacketWirelen</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the wire length of the packet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/jnetpcap/packet/JScanner.html" title="class in org.jnetpcap.packet">JScanner</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#getScanner()">getScanner</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>use static <A HREF="../../../org/jnetpcap/packet/JPacket.html#getDefaultScanner()"><CODE>getDefaultScanner()</CODE></A> instead</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/jnetpcap/packet/JPacket.State.html" title="class in org.jnetpcap.packet">JPacket.State</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#getState()">getState</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the peered packet state object</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#getTotalSize()">getTotalSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the total size of this packet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#hasAllHeaders(long)">hasAllHeaders</A></B>(long&nbsp;mask)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if all of the headers present in the bitmask are found in the
 packet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#hasAnyHeader(long)">hasAnyHeader</A></B>(long&nbsp;mask)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if any of the headers present in the bitmask are found in the
 packet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#hasHeader(int)">hasHeader</A></B>(int&nbsp;id)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if header with specified numerical ID exists within the decoded
 packet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#hasHeader(int, int)">hasHeader</A></B>(int&nbsp;id,
          int&nbsp;instance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check if requested instance of header with specified numerical ID exists
 within the decoded packet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends <A HREF="../../../org/jnetpcap/packet/JHeader.html" title="class in org.jnetpcap.packet">JHeader</A>&gt; 
<BR>
boolean</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#hasHeader(T)">hasHeader</A></B>(T&nbsp;header)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check if requested instance of header with specified numerical ID exists
 within the decoded packet and if found peers the supplied header with the
 located header within the decoded packet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends <A HREF="../../../org/jnetpcap/packet/JHeader.html" title="class in org.jnetpcap.packet">JHeader</A>&gt; 
<BR>
boolean</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#hasHeader(T, int)">hasHeader</A></B>(T&nbsp;header,
          int&nbsp;instance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check if requested instance of header with specified numerical ID exists
 within the decoded packet and if found peers the supplied header with the
 located header within the decoded packet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Iterator&lt;<A HREF="../../../org/jnetpcap/packet/JHeader.html" title="class in org.jnetpcap.packet">JHeader</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#iterator()">iterator</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Uses a thread-local based <code>JHeaderPool</code> to iterate over all
 the headers within a packet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; java.util.Iterator&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#iterator(java.lang.Class)">iterator</A></B>(java.lang.Class&lt;T&gt;&nbsp;type)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Uses a thread-local based <code>JHeaderPool</code> to iterate over all
 the headers within a packet that are instances of the specified type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#recalculateAllChecksums()">recalculateAllChecksums</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method recalculates header CRC for every header that supports
 JHeaderChecksum interface.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#remaining(int)">remaining</A></B>(int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculates the number of bytes remaining within the packet given a
 specific offset.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#remaining(int, int)">remaining</A></B>(int&nbsp;offset,
          int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculates the remaining number of bytes within the packet buffer taking
 into account offset and length of a header supplied.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#scan(int)">scan</A></B>(int&nbsp;id)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scan and decode the packet using current scanner.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#setDefaultHeaderPool(org.jnetpcap.packet.JHeaderPool)">setDefaultHeaderPool</A></B>(<A HREF="../../../org/jnetpcap/packet/JHeaderPool.html" title="class in org.jnetpcap.packet">JHeaderPool</A>&nbsp;headerPool)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the default header pool.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#setFormatter(org.jnetpcap.packet.format.JFormatter)">setFormatter</A></B>(<A HREF="../../../org/jnetpcap/packet/format/JFormatter.html" title="class in org.jnetpcap.packet.format">JFormatter</A>&nbsp;out)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replaced the default formatter for formatting output in the.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#setMemoryPool(org.jnetpcap.nio.JMemoryPool)">setMemoryPool</A></B>(<A HREF="../../../org/jnetpcap/nio/JMemoryPool.html" title="class in org.jnetpcap.nio">JMemoryPool</A>&nbsp;pool)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replaces the default memory allocation mechanism with user supplied one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#shutdown()">shutdown</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shutdown.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#toHexdump()">toHexdump</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Formats packet raw data as a hexdump output and marks header boundaries
 with special characters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/packet/JPacket.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generates text formatted output using the default builtin formatter.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_org.jnetpcap.nio.JBuffer"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class org.jnetpcap.nio.<A HREF="../../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../org/jnetpcap/nio/JBuffer.html#findUTF8String(int, char...)">findUTF8String</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#getByte(int)">getByte</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#getByteArray(int, byte[])">getByteArray</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#getByteArray(int, byte[], int, int)">getByteArray</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#getByteArray(int, int)">getByteArray</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#getDouble(int)">getDouble</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#getFloat(int)">getFloat</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#getInt(int)">getInt</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#getLong(int)">getLong</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#getShort(int)">getShort</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#getUByte(int)">getUByte</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#getUInt(int)">getUInt</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#getUShort(int)">getUShort</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#getUTF8Char(int)">getUTF8Char</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#getUTF8String(int, char...)">getUTF8String</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#getUTF8String(int, int)">getUTF8String</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#getUTF8String(int, java.lang.StringBuilder, char...)">getUTF8String</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#getUTF8String(int, java.lang.StringBuilder, int)">getUTF8String</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#isReadonly()">isReadonly</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#order()">order</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#order(java.nio.ByteOrder)">order</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#peer(java.nio.ByteBuffer)">peer</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#peer(org.jnetpcap.nio.JBuffer)">peer</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#peer(org.jnetpcap.nio.JBuffer, int, int)">peer</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#peer(org.jnetpcap.nio.JMemory)">peer</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#setByte(int, byte)">setByte</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#setByteArray(int, byte[])">setByteArray</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#setByteBuffer(int, java.nio.ByteBuffer)">setByteBuffer</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#setDouble(int, double)">setDouble</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#setFloat(int, float)">setFloat</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#setInt(int, int)">setInt</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#setLong(int, long)">setLong</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#setShort(int, short)">setShort</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#setShort0(long, boolean, int, short)">setShort0</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#setUByte(int, int)">setUByte</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#setUInt(int, long)">setUInt</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#setUShort(int, int)">setUShort</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#transferFrom(byte[])">transferFrom</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#transferFrom(java.nio.ByteBuffer, int)">transferFrom</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#transferFrom(org.jnetpcap.nio.JBuffer)">transferFrom</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#transferTo(java.nio.ByteBuffer, int, int)">transferTo</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#transferTo(org.jnetpcap.nio.JBuffer)">transferTo</A>, <A HREF="../../../org/jnetpcap/nio/JBuffer.html#transferTo(org.jnetpcap.nio.JBuffer, int, int, int)">transferTo</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_org.jnetpcap.nio.JMemory"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class org.jnetpcap.nio.<A HREF="../../../org/jnetpcap/nio/JMemory.html" title="class in org.jnetpcap.nio">JMemory</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../org/jnetpcap/nio/JMemory.html#availableDirectMemory()">availableDirectMemory</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#check()">check</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#cleanup()">cleanup</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#createReference(long, long)">createReference</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#isInitialized()">isInitialized</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#isJMemoryBasedOwner()">isJMemoryBasedOwner</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#isOwner()">isOwner</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#maxDirectMemory()">maxDirectMemory</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#peer(org.jnetpcap.nio.JMemory, int, int)">peer</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#reservedDirectMemory()">reservedDirectMemory</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#setSize(int)">setSize</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#size()">size</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#softDirectMemory()">softDirectMemory</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#toDebugString()">toDebugString</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#toHexdump(int, boolean, boolean, boolean)">toHexdump</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#totalActiveAllocated()">totalActiveAllocated</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#totalAllocateCalls()">totalAllocateCalls</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#totalAllocated()">totalAllocated</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#totalAllocatedSegments0To255Bytes()">totalAllocatedSegments0To255Bytes</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#totalAllocatedSegments256OrAbove()">totalAllocatedSegments256OrAbove</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#totalDeAllocateCalls()">totalDeAllocateCalls</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#totalDeAllocated()">totalDeAllocated</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#transferFrom(byte[], int, int, int)">transferFrom</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#transferFrom(java.nio.ByteBuffer)">transferFrom</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#transferFromDirect(java.nio.ByteBuffer, int)">transferFromDirect</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#transferOwnership(org.jnetpcap.nio.JMemory)">transferOwnership</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#transferTo(byte[])">transferTo</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#transferTo(byte[], int, int, int)">transferTo</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#transferTo(java.nio.ByteBuffer)">transferTo</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#transferTo(org.jnetpcap.nio.JMemory)">transferTo</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#transferTo(org.jnetpcap.nio.JMemory, int, int, int)">transferTo</A>, <A HREF="../../../org/jnetpcap/nio/JMemory.html#transferTo0(long, byte[], int, int, int)">transferTo0</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="DEFAULT_STATE_HEADER_COUNT"><!-- --></A><H3>
DEFAULT_STATE_HEADER_COUNT</H3>
<PRE>
public static final int <B>DEFAULT_STATE_HEADER_COUNT</B></PRE>
<DL>
<DD>Default number of headers used when calculating memory requirements for
 an empty packet state structure. This value will be multiplied by the
 sizeof(header_t) structure and added to the size of the packet_t
 strcutre.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.jnetpcap.packet.JPacket.DEFAULT_STATE_HEADER_COUNT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="defaultScanner"><!-- --></A><H3>
defaultScanner</H3>
<PRE>
protected static <A HREF="../../../org/jnetpcap/packet/JScanner.html" title="class in org.jnetpcap.packet">JScanner</A> <B>defaultScanner</B></PRE>
<DL>
<DD>Default scanner used to scan a packet per user request.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="pool"><!-- --></A><H3>
pool</H3>
<PRE>
protected static <A HREF="../../../org/jnetpcap/nio/JMemoryPool.html" title="class in org.jnetpcap.nio">JMemoryPool</A> <B>pool</B></PRE>
<DL>
<DD>Packet's default memory pool out of which allocates memory for deep
 copies.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="memory"><!-- --></A><H3>
memory</H3>
<PRE>
protected final <A HREF="../../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</A> <B>memory</B></PRE>
<DL>
<DD>The allocated memory buffer. Initialy this buffer is empty, but may be
 peered with allocated memory for internal usage such as copying header,
 state and data into a single buffer
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="state"><!-- --></A><H3>
state</H3>
<PRE>
protected final <A HREF="../../../org/jnetpcap/packet/JPacket.State.html" title="class in org.jnetpcap.packet">JPacket.State</A> <B>state</B></PRE>
<DL>
<DD>Packet's state structure.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="JPacket(int, int)"><!-- --></A><H3>
JPacket</H3>
<PRE>
public <B>JPacket</B>(int&nbsp;size,
               int&nbsp;state)</PRE>
<DL>
<DD>Allocates a memory block and peers both the state and data buffer with
 it. The size parameter has to be big enough to hold both state and data
 for the packet.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>size</CODE> - amount of memory to allocate for packet data<DD><CODE>state</CODE> - size of the state</DL>
</DL>
<HR>

<A NAME="JPacket(org.jnetpcap.nio.JMemory.Type)"><!-- --></A><H3>
JPacket</H3>
<PRE>
public <B>JPacket</B>(<A HREF="../../../org/jnetpcap/nio/JMemory.Type.html" title="enum in org.jnetpcap.nio">JMemory.Type</A>&nbsp;type)</PRE>
<DL>
<DD>A JPacket pointer. This is a pointer type constructor that does not
 allocate any memory but its intended to be pointed at a scanner packet_t
 structure that contains meta information about the structure of the
 packet data buffer.
 <p>
 JPacket constists of 2 peers. The first and the main memory peering is
 with the packet_state_t structure which stores information about the
 decoded state of the packet, another words the result of the scanned
 packet data buffer. The second peer is to the actual packet data buffer
 which is a seperate pointer.
 <h2>Peering struct packet_t</h2>
 This structure contains the "packet state". This is the decoded state
 which specifies what headers are in the buffer and at what offsets. This
 structure is the output of a JScanner.scan() method. The memory for this
 state can be anywhere, but by default JScanner stores it in a round-robin
 buffer it uses for decoding fast incoming packets. The state can easily
 be copied into another buffer for longer storage using such methods as
 <code>transferStateAndDataTo</code> which will copy the packet state
 and/or data buffer into another memory area, such as a direct ByteBuffer
 or JBuffer.
 </p>
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>type</CODE> - the type</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getDefaultHeaderPool()"><!-- --></A><H3>
getDefaultHeaderPool</H3>
<PRE>
public static <A HREF="../../../org/jnetpcap/packet/JHeaderPool.html" title="class in org.jnetpcap.packet">JHeaderPool</A> <B>getDefaultHeaderPool</B>()</PRE>
<DL>
<DD>Gets the default header pool.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the default header pool</DL>
</DD>
</DL>
<HR>

<A NAME="getDefaultScanner()"><!-- --></A><H3>
getDefaultScanner</H3>
<PRE>
public static <A HREF="../../../org/jnetpcap/packet/JScanner.html" title="class in org.jnetpcap.packet">JScanner</A> <B>getDefaultScanner</B>()</PRE>
<DL>
<DD>Returns the default scanner for all packets
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the current default scanner</DL>
</DD>
</DL>
<HR>

<A NAME="getFormatter()"><!-- --></A><H3>
getFormatter</H3>
<PRE>
public static <A HREF="../../../org/jnetpcap/packet/format/JFormatter.html" title="class in org.jnetpcap.packet.format">JFormatter</A> <B>getFormatter</B>()</PRE>
<DL>
<DD>Gets the current internal packet formatter used in the <A HREF="../../../org/jnetpcap/packet/JPacket.html#toString()"><CODE>toString()</CODE></A>
 method.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>current formatter</DL>
</DD>
</DL>
<HR>

<A NAME="getMemoryPool()"><!-- --></A><H3>
getMemoryPool</H3>
<PRE>
public static <A HREF="../../../org/jnetpcap/nio/JMemoryPool.html" title="class in org.jnetpcap.nio">JMemoryPool</A> <B>getMemoryPool</B>()</PRE>
<DL>
<DD>Gets the current memory allocation memory pool.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>current memory pool</DL>
</DD>
</DL>
<HR>

<A NAME="setDefaultHeaderPool(org.jnetpcap.packet.JHeaderPool)"><!-- --></A><H3>
setDefaultHeaderPool</H3>
<PRE>
public static void <B>setDefaultHeaderPool</B>(<A HREF="../../../org/jnetpcap/packet/JHeaderPool.html" title="class in org.jnetpcap.packet">JHeaderPool</A>&nbsp;headerPool)</PRE>
<DL>
<DD>Sets the default header pool.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>headerPool</CODE> - the new default header pool</DL>
</DD>
</DL>
<HR>

<A NAME="setFormatter(org.jnetpcap.packet.format.JFormatter)"><!-- --></A><H3>
setFormatter</H3>
<PRE>
public static void <B>setFormatter</B>(<A HREF="../../../org/jnetpcap/packet/format/JFormatter.html" title="class in org.jnetpcap.packet.format">JFormatter</A>&nbsp;out)</PRE>
<DL>
<DD>Replaced the default formatter for formatting output in the.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>out</CODE> - new formatter <A HREF="../../../org/jnetpcap/packet/JPacket.html#toString()"><CODE>toString()</CODE></A> method. The new formatter will
            be used by default for all packets. The formatter should
            internally build a string that will be returned with
            out.toString() method call to get meaningfull output.</DL>
</DD>
</DL>
<HR>

<A NAME="setMemoryPool(org.jnetpcap.nio.JMemoryPool)"><!-- --></A><H3>
setMemoryPool</H3>
<PRE>
public static void <B>setMemoryPool</B>(<A HREF="../../../org/jnetpcap/nio/JMemoryPool.html" title="class in org.jnetpcap.nio">JMemoryPool</A>&nbsp;pool)</PRE>
<DL>
<DD>Replaces the default memory allocation mechanism with user supplied one.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pool</CODE> - new memory pool to use.</DL>
</DD>
</DL>
<HR>

<A NAME="shutdown()"><!-- --></A><H3>
shutdown</H3>
<PRE>
public static void <B>shutdown</B>()</PRE>
<DL>
<DD>Shutdown.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="allocate(int)"><!-- --></A><H3>
allocate</H3>
<PRE>
public void <B>allocate</B>(int&nbsp;size)</PRE>
<DL>
<DD>Creates a new memory buffer of given size for internal usage.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>size</CODE> - size in bytes</DL>
</DD>
</DL>
<HR>

<A NAME="filterByType(java.lang.Class)"><!-- --></A><H3>
filterByType</H3>
<PRE>
public &lt;T&gt; java.lang.Iterable&lt;T&gt; <B>filterByType</B>(java.lang.Class&lt;T&gt;&nbsp;type)</PRE>
<DL>
<DD>Filter existing header instances by specified type.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the generic type<DT><B>Parameters:</B><DD><CODE>type</CODE> - the clazz
<DT><B>Returns:</B><DD>the iterable<DT><B>Since:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getAllocatedMemorySize()"><!-- --></A><H3>
getAllocatedMemorySize</H3>
<PRE>
public int <B>getAllocatedMemorySize</B>()</PRE>
<DL>
<DD>Gets the size of the current internal memory buffer.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>length in bytes</DL>
</DD>
</DL>
<HR>

<A NAME="getCaptureHeader()"><!-- --></A><H3>
getCaptureHeader</H3>
<PRE>
public abstract <A HREF="../../../org/jnetpcap/JCaptureHeader.html" title="interface in org.jnetpcap">JCaptureHeader</A> <B>getCaptureHeader</B>()</PRE>
<DL>
<DD>Gets the capture header as generated by the native capture library.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>capture header</DL>
</DD>
</DL>
<HR>

<A NAME="getFlowKey()"><!-- --></A><H3>
getFlowKey</H3>
<PRE>
public <A HREF="../../../org/jnetpcap/packet/JFlowKey.html" title="class in org.jnetpcap.packet">JFlowKey</A> <B>getFlowKey</B>()</PRE>
<DL>
<DD>Gets the unique flow-key for this packet. This method instantiates a
 flow-key object and peers is with native flow-key state. The flow-key
 reference is retained and returned on any subsequent invocations.
 <p>
 Flow-keys are generated for each packet and can be used to group packets
 into similar group of packets into flows. Flows associate packets that
 are flowing in the same or are part of the same group of packets. For
 example, TCP/IP group of packets will be grouped into flows, by
 generating appropriate flow-keys, so that all packets part of the same
 TCP stream, will have the exact same flow-key generated, allowing those
 packets to be grouped into a single flow. Flow-keys can be uni or bi
 directional.
 </p>
 <p>
 Uni-directional flow, is generated for packets that should be grouped, or
 belong to the same flow, where packets are sent from System A to System
 B, in a single or uni direction. Bi-directional keys are generated for
 packets that should belong to the same flow, in both directions. Packets
 that are sent from System A to System B and packets that are sent from
 System B to System A.
 </p>
 <p>
 The criteria used for generating flow-keys is different for each packet
 based on protocol headers present in the packet. As an example, a
 flow-key for a Ethernet/Ip4/Tcp packet is generated based on source and
 destination ethernet addresses, source and destination Ip4 address, the
 Ip4 protocol/type number 16 which signifies that next protocol is TCP and
 source and destination TCP port numbers. The flow-key generated for this
 example is bidirectional, meaning that packets belonging to the same TCP
 conversation in both directions between System A and System B will have
 the exact same flow-key generated.
 </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a unique flow-key object</DL>
</DD>
</DL>
<HR>

<A NAME="getFlowKey(org.jnetpcap.packet.JFlowKey)"><!-- --></A><H3>
getFlowKey</H3>
<PRE>
public <A HREF="../../../org/jnetpcap/packet/JFlowKey.html" title="class in org.jnetpcap.packet">JFlowKey</A> <B>getFlowKey</B>(<A HREF="../../../org/jnetpcap/packet/JFlowKey.html" title="class in org.jnetpcap.packet">JFlowKey</A>&nbsp;key)</PRE>
<DL>
<DD>Gets the unique flow-key for this packet. This method peers the
 <p>
 Flow-keys are generated for each packet and can be used to group packets
 into similar group of packets into flows. Flows associate packets that
 are flowing in the same or are part of the same group of packets. For
 example, TCP/IP group of packets will be grouped into flows, by
 generating appropriate flow-keys, so that all packets part of the same
 TCP stream, will have the exact same flow-key generated, allowing those
 packets to be grouped into a single flow. Flow-keys can be uni or bi
 directional.
 </p>
 <p>
 Uni-directional flow, is generated for packets that should be grouped, or
 belong to the same flow, where packets are sent from System A to System
 B, in a single or uni direction. Bi-directional keys are generated for
 packets that should belong to the same flow, in both directions. Packets
 that are sent from System A to System B and packets that are sent from
 System B to System A.
 </p>
 <p>
 The criteria used for generating flow-keys is different for each packet
 based on protocol headers present in the packet. As an example, a
 flow-key for a Ethernet/Ip4/Tcp packet is generated based on source and
 destination ethernet addresses, source and destination Ip4 address, the
 Ip4 protocol/type number 16 which signifies that next protocol is TCP and
 source and destination TCP port numbers. The flow-key generated for this
 example is bidirectional, meaning that packets belonging to the same TCP
 conversation in both directions between System A and System B will have
 the exact same flow-key generated.
 </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a unique flow-key object</DL>
</DD>
</DL>
<HR>

<A NAME="getFrameNumber()"><!-- --></A><H3>
getFrameNumber</H3>
<PRE>
public long <B>getFrameNumber</B>()</PRE>
<DL>
<DD>Returns the frame number as assigned by either the packet scanner or
 analyzers.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>zero based frame number</DL>
</DD>
</DL>
<HR>

<A NAME="getHeader(org.jnetpcap.packet.JHeader)"><!-- --></A><A NAME="getHeader(T)"><!-- --></A><H3>
getHeader</H3>
<PRE>
public &lt;T extends <A HREF="../../../org/jnetpcap/packet/JHeader.html" title="class in org.jnetpcap.packet">JHeader</A>&gt; T <B>getHeader</B>(T&nbsp;header)</PRE>
<DL>
<DD>Peers the supplied header with the native header state structure and
 packet data buffer.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../org/jnetpcap/packet/JHeaderAccessor.html#getHeader(T)">getHeader</A></CODE> in interface <CODE><A HREF="../../../org/jnetpcap/packet/JHeaderAccessor.html" title="interface in org.jnetpcap.packet">JHeaderAccessor</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - name of the header<DT><B>Parameters:</B><DD><CODE>header</CODE> - instance of a header object
<DT><B>Returns:</B><DD>the supplied instance of the header</DL>
</DD>
</DL>
<HR>

<A NAME="getHeader(org.jnetpcap.packet.JHeader,int)"><!-- --></A><A NAME="getHeader(T, int)"><!-- --></A><H3>
getHeader</H3>
<PRE>
public &lt;T extends <A HREF="../../../org/jnetpcap/packet/JHeader.html" title="class in org.jnetpcap.packet">JHeader</A>&gt; T <B>getHeader</B>(T&nbsp;header,
                                       int&nbsp;instance)</PRE>
<DL>
<DD>Peers the supplied header with the native header state structure and
 packet data buffer. This method allows retrieval of a specific instance
 of a header if more than one instance has been found.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../org/jnetpcap/packet/JHeaderAccessor.html#getHeader(T, int)">getHeader</A></CODE> in interface <CODE><A HREF="../../../org/jnetpcap/packet/JHeaderAccessor.html" title="interface in org.jnetpcap.packet">JHeaderAccessor</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - name of the header<DT><B>Parameters:</B><DD><CODE>header</CODE> - instance of a header object<DD><CODE>instance</CODE> - instance number of the header since more than one header of
            the same type can exist in the same packet buffer
<DT><B>Returns:</B><DD>the supplied instance of the header</DL>
</DD>
</DL>
<HR>

<A NAME="getHeaderByIndex(int,org.jnetpcap.packet.JHeader)"><!-- --></A><A NAME="getHeaderByIndex(int, T)"><!-- --></A><H3>
getHeaderByIndex</H3>
<PRE>
public &lt;T extends <A HREF="../../../org/jnetpcap/packet/JHeader.html" title="class in org.jnetpcap.packet">JHeader</A>&gt; T <B>getHeaderByIndex</B>(int&nbsp;index,
                                              T&nbsp;header)
                                   throws java.lang.IndexOutOfBoundsException</PRE>
<DL>
<DD>Peers a header with specific index, not the numerical header ID assigned
 by JRegistry, of a header.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../org/jnetpcap/packet/JHeaderAccessor.html#getHeaderByIndex(int, T)">getHeaderByIndex</A></CODE> in interface <CODE><A HREF="../../../org/jnetpcap/packet/JHeaderAccessor.html" title="interface in org.jnetpcap.packet">JHeaderAccessor</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - name of the header<DT><B>Parameters:</B><DD><CODE>index</CODE> - index into the header array the scanner has found<DD><CODE>header</CODE> - instance of a header object
<DT><B>Returns:</B><DD>the supplied header
<DT><B>Throws:</B>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - the index out of bounds exception</DL>
</DD>
</DL>
<HR>

<A NAME="getHeaderCount()"><!-- --></A><H3>
getHeaderCount</H3>
<PRE>
public int <B>getHeaderCount</B>()</PRE>
<DL>
<DD>Gets number of headers found within the packet header. The last header
 may or may not be the builtin Payload header
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../org/jnetpcap/packet/JHeaderAccessor.html#getHeaderCount()">getHeaderCount</A></CODE> in interface <CODE><A HREF="../../../org/jnetpcap/packet/JHeaderAccessor.html" title="interface in org.jnetpcap.packet">JHeaderAccessor</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>number of headers present</DL>
</DD>
</DL>
<HR>

<A NAME="getHeaderIdByIndex(int)"><!-- --></A><H3>
getHeaderIdByIndex</H3>
<PRE>
public int <B>getHeaderIdByIndex</B>(int&nbsp;index)</PRE>
<DL>
<DD>Gets the numerical ID of the header at specified index into header array
 as found by the packet scanner.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../org/jnetpcap/packet/JHeaderAccessor.html#getHeaderIdByIndex(int)">getHeaderIdByIndex</A></CODE> in interface <CODE><A HREF="../../../org/jnetpcap/packet/JHeaderAccessor.html" title="interface in org.jnetpcap.packet">JHeaderAccessor</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - index into the header array
<DT><B>Returns:</B><DD>numerical ID of the header found at the specific index</DL>
</DD>
</DL>
<HR>

<A NAME="getHeaderInstanceCount(int)"><!-- --></A><H3>
getHeaderInstanceCount</H3>
<PRE>
public int <B>getHeaderInstanceCount</B>(int&nbsp;id)</PRE>
<DL>
<DD>Gets number of headers with the same numerical ID as assigned by
 JRegistry within the same packet. For example Ip4 in ip4 packet would
 contain 2 instances of Ip4 header.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../org/jnetpcap/packet/JHeaderAccessor.html#getHeaderInstanceCount(int)">getHeaderInstanceCount</A></CODE> in interface <CODE><A HREF="../../../org/jnetpcap/packet/JHeaderAccessor.html" title="interface in org.jnetpcap.packet">JHeaderAccessor</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>id</CODE> - numerical ID of the header to search for
<DT><B>Returns:</B><DD>number of headers of the same type in the packet</DL>
</DD>
</DL>
<HR>

<A NAME="getMemoryBuffer(byte[])"><!-- --></A><H3>
getMemoryBuffer</H3>
<PRE>
protected <A HREF="../../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</A> <B>getMemoryBuffer</B>(byte[]&nbsp;buffer)</PRE>
<DL>
<DD>Gets the memory buffer with the supplied byte array data copied into it.
 The internal memory buffer is allocated if neccessary.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buffer</CODE> - source array buffer to copy data out of
<DT><B>Returns:</B><DD>the memory buffer</DL>
</DD>
</DL>
<HR>

<A NAME="getMemoryBuffer(java.nio.ByteBuffer)"><!-- --></A><H3>
getMemoryBuffer</H3>
<PRE>
protected <A HREF="../../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</A> <B>getMemoryBuffer</B>(java.nio.ByteBuffer&nbsp;buffer)
                           throws <A HREF="../../../org/jnetpcap/packet/PeeringException.html" title="class in org.jnetpcap.packet">PeeringException</A></PRE>
<DL>
<DD>Gets the memory buffer with the supplied ByteBuffer data copied into it.
 The internal memory buffer is allocated if neccessary.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buffer</CODE> - source array buffer to copy data out of
<DT><B>Returns:</B><DD>the memory buffer
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/jnetpcap/packet/PeeringException.html" title="class in org.jnetpcap.packet">PeeringException</A></CODE> - the peering exception</DL>
</DD>
</DL>
<HR>

<A NAME="getMemoryBuffer(int)"><!-- --></A><H3>
getMemoryBuffer</H3>
<PRE>
protected <A HREF="../../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</A> <B>getMemoryBuffer</B>(int&nbsp;minSize)</PRE>
<DL>
<DD>Retrieves a memory buffer, allocated if neccessary, at least minSize in
 bytes. If existing buffer is already big enough, it is returned,
 otherwise a new buffer is allocated and the existing one released.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>minSize</CODE> - minimum number of bytes required for the buffer
<DT><B>Returns:</B><DD>the buffer</DL>
</DD>
</DL>
<HR>

<A NAME="getMemoryBuffer(org.jnetpcap.nio.JBuffer)"><!-- --></A><H3>
getMemoryBuffer</H3>
<PRE>
protected <A HREF="../../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</A> <B>getMemoryBuffer</B>(<A HREF="../../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</A>&nbsp;buffer)</PRE>
<DL>
<DD>Gets the memory buffer with the supplied JBuffer data copied into it. The
 internal memory buffer is allocated if neccessary.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buffer</CODE> - source array buffer to copy data out of
<DT><B>Returns:</B><DD>the memory buffer</DL>
</DD>
</DL>
<HR>

<A NAME="getPacketWirelen()"><!-- --></A><H3>
getPacketWirelen</H3>
<PRE>
public int <B>getPacketWirelen</B>()</PRE>
<DL>
<DD>Gets the wire length of the packet. This is the original length as seen
 on the wire. This length may different JPacket.size() length, as the
 packet may have been truncated at the time of the capture.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>original packet length</DL>
</DD>
</DL>
<HR>

<A NAME="getScanner()"><!-- --></A><H3>
getScanner</H3>
<PRE>
<FONT SIZE="-1">@Deprecated
</FONT>public <A HREF="../../../org/jnetpcap/packet/JScanner.html" title="class in org.jnetpcap.packet">JScanner</A> <B>getScanner</B>()</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>use static <A HREF="../../../org/jnetpcap/packet/JPacket.html#getDefaultScanner()"><CODE>getDefaultScanner()</CODE></A> instead</I>
<P>
<DD>Gets the current default scanner.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>current default scanner</DL>
</DD>
</DL>
<HR>

<A NAME="getState()"><!-- --></A><H3>
getState</H3>
<PRE>
public <A HREF="../../../org/jnetpcap/packet/JPacket.State.html" title="class in org.jnetpcap.packet">JPacket.State</A> <B>getState</B>()</PRE>
<DL>
<DD>Gets the peered packet state object
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>packet native state</DL>
</DD>
</DL>
<HR>

<A NAME="getTotalSize()"><!-- --></A><H3>
getTotalSize</H3>
<PRE>
public abstract int <B>getTotalSize</B>()</PRE>
<DL>
<DD>Gets the total size of this packet. The size includes state, header and
 packet data.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>size in bytes</DL>
</DD>
</DL>
<HR>

<A NAME="hasAllHeaders(long)"><!-- --></A><H3>
hasAllHeaders</H3>
<PRE>
public boolean <B>hasAllHeaders</B>(long&nbsp;mask)</PRE>
<DL>
<DD>Checks if all of the headers present in the bitmask are found in the
 packet.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mask</CODE> - bitmask of encoded headers
<DT><B>Returns:</B><DD>true if all of the headers are present<DT><B>Since:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hasAnyHeader(long)"><!-- --></A><H3>
hasAnyHeader</H3>
<PRE>
public boolean <B>hasAnyHeader</B>(long&nbsp;mask)</PRE>
<DL>
<DD>Checks if any of the headers present in the bitmask are found in the
 packet.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mask</CODE> - bitmask of encoded headers
<DT><B>Returns:</B><DD>true if any (1 or more) of the headers in the bitmask are present<DT><B>Since:</B></DT>
  <DD>1.4</DD>
<DT><B>See Also:</B><DD><A HREF="../../../org/jnetpcap/protocol/JProtocol.html#createMaskFromIds(int...)"><CODE>JProtocol.createMaskFromIds(int...)</CODE></A>, 
<A HREF="../../../org/jnetpcap/protocol/JProtocol.html#createMaskFromMasks(long...)"><CODE>JProtocol.createMaskFromMasks(long...)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="hasHeader(int)"><!-- --></A><H3>
hasHeader</H3>
<PRE>
public boolean <B>hasHeader</B>(int&nbsp;id)</PRE>
<DL>
<DD>Checks if header with specified numerical ID exists within the decoded
 packet.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../org/jnetpcap/packet/JHeaderAccessor.html#hasHeader(int)">hasHeader</A></CODE> in interface <CODE><A HREF="../../../org/jnetpcap/packet/JHeaderAccessor.html" title="interface in org.jnetpcap.packet">JHeaderAccessor</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>id</CODE> - protocol header ID as assigned by JRegistry
<DT><B>Returns:</B><DD>true header exists, otherwise false</DL>
</DD>
</DL>
<HR>

<A NAME="hasHeader(int, int)"><!-- --></A><H3>
hasHeader</H3>
<PRE>
public boolean <B>hasHeader</B>(int&nbsp;id,
                         int&nbsp;instance)</PRE>
<DL>
<DD>Check if requested instance of header with specified numerical ID exists
 within the decoded packet.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../org/jnetpcap/packet/JHeaderAccessor.html#hasHeader(int, int)">hasHeader</A></CODE> in interface <CODE><A HREF="../../../org/jnetpcap/packet/JHeaderAccessor.html" title="interface in org.jnetpcap.packet">JHeaderAccessor</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>id</CODE> - protocol header ID as assigned by JRegistry<DD><CODE>instance</CODE> - instance number of the specific header within the packet
<DT><B>Returns:</B><DD>true header exists, otherwise false</DL>
</DD>
</DL>
<HR>

<A NAME="hasHeader(org.jnetpcap.packet.JHeader)"><!-- --></A><A NAME="hasHeader(T)"><!-- --></A><H3>
hasHeader</H3>
<PRE>
public &lt;T extends <A HREF="../../../org/jnetpcap/packet/JHeader.html" title="class in org.jnetpcap.packet">JHeader</A>&gt; boolean <B>hasHeader</B>(T&nbsp;header)</PRE>
<DL>
<DD>Check if requested instance of header with specified numerical ID exists
 within the decoded packet and if found peers the supplied header with the
 located header within the decoded packet. This method executes as
 hasHeader followed by getHeader if found more efficiently.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../org/jnetpcap/packet/JHeaderAccessor.html#hasHeader(T)">hasHeader</A></CODE> in interface <CODE><A HREF="../../../org/jnetpcap/packet/JHeaderAccessor.html" title="interface in org.jnetpcap.packet">JHeaderAccessor</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - name of the header type<DT><B>Parameters:</B><DD><CODE>header</CODE> - protocol header object instance
<DT><B>Returns:</B><DD>true header exists, otherwise false</DL>
</DD>
</DL>
<HR>

<A NAME="hasHeader(org.jnetpcap.packet.JHeader,int)"><!-- --></A><A NAME="hasHeader(T, int)"><!-- --></A><H3>
hasHeader</H3>
<PRE>
public &lt;T extends <A HREF="../../../org/jnetpcap/packet/JHeader.html" title="class in org.jnetpcap.packet">JHeader</A>&gt; boolean <B>hasHeader</B>(T&nbsp;header,
                                             int&nbsp;instance)</PRE>
<DL>
<DD>Check if requested instance of header with specified numerical ID exists
 within the decoded packet and if found peers the supplied header with the
 located header within the decoded packet. This method executes as
 hasHeader followed by getHeader if found more efficiently.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../org/jnetpcap/packet/JHeaderAccessor.html#hasHeader(T, int)">hasHeader</A></CODE> in interface <CODE><A HREF="../../../org/jnetpcap/packet/JHeaderAccessor.html" title="interface in org.jnetpcap.packet">JHeaderAccessor</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - name of the header type<DT><B>Parameters:</B><DD><CODE>header</CODE> - protocol header object instance<DD><CODE>instance</CODE> - instance number of the specific header within the packet
<DT><B>Returns:</B><DD>true header exists, otherwise false</DL>
</DD>
</DL>
<HR>

<A NAME="iterator()"><!-- --></A><H3>
iterator</H3>
<PRE>
public java.util.Iterator&lt;<A HREF="../../../org/jnetpcap/packet/JHeader.html" title="class in org.jnetpcap.packet">JHeader</A>&gt; <B>iterator</B>()</PRE>
<DL>
<DD>Uses a thread-local based <code>JHeaderPool</code> to iterate over all
 the headers within a packet.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>iterator</CODE> in interface <CODE>java.lang.Iterable&lt;<A HREF="../../../org/jnetpcap/packet/JHeader.html" title="class in org.jnetpcap.packet">JHeader</A>&gt;</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the iterator<DT><B>Since:</B></DT>
  <DD>1.4</DD>
<DT><B>See Also:</B><DD><CODE>Iterable.iterator()</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="iterator(java.lang.Class)"><!-- --></A><H3>
iterator</H3>
<PRE>
public &lt;T&gt; java.util.Iterator&lt;T&gt; <B>iterator</B>(java.lang.Class&lt;T&gt;&nbsp;type)</PRE>
<DL>
<DD>Uses a thread-local based <code>JHeaderPool</code> to iterate over all
 the headers within a packet that are instances of the specified type.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the generic type<DT><B>Parameters:</B><DD><CODE>type</CODE> - the class used to check if a header is in assignable to this
            type
<DT><B>Returns:</B><DD>the iterator</DL>
</DD>
</DL>
<HR>

<A NAME="recalculateAllChecksums()"><!-- --></A><H3>
recalculateAllChecksums</H3>
<PRE>
public void <B>recalculateAllChecksums</B>()</PRE>
<DL>
<DD>Method recalculates header CRC for every header that supports
 JHeaderChecksum interface. The new CRC values are written back into the
 headers.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="remaining(int)"><!-- --></A><H3>
remaining</H3>
<PRE>
public int <B>remaining</B>(int&nbsp;offset)</PRE>
<DL>
<DD>Calculates the number of bytes remaining within the packet given a
 specific offset.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - offset into the packet in bytes
<DT><B>Returns:</B><DD>number of bytes remaining from specified offset</DL>
</DD>
</DL>
<HR>

<A NAME="remaining(int, int)"><!-- --></A><H3>
remaining</H3>
<PRE>
public int <B>remaining</B>(int&nbsp;offset,
                     int&nbsp;length)</PRE>
<DL>
<DD>Calculates the remaining number of bytes within the packet buffer taking
 into account offset and length of a header supplied. The smaller of the 2
 is returned. This should typically be the length field unless the header
 has been truncated and remaining number of bytes is less.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - offset of the header to take into account<DD><CODE>length</CODE> - length of the header
<DT><B>Returns:</B><DD>smaller number of bytes either remaining or legth</DL>
</DD>
</DL>
<HR>

<A NAME="scan(int)"><!-- --></A><H3>
scan</H3>
<PRE>
public void <B>scan</B>(int&nbsp;id)</PRE>
<DL>
<DD>Scan and decode the packet using current scanner. The new packet state
 replaces any existing packet state already asigned to this packet.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>id</CODE> - numerical ID as assigned by JRegistry of the first protocol
            header to be found in the packet, the DLT</DL>
</DD>
</DL>
<HR>

<A NAME="toHexdump()"><!-- --></A><H3>
toHexdump</H3>
<PRE>
public java.lang.String <B>toHexdump</B>()</PRE>
<DL>
<DD>Formats packet raw data as a hexdump output and marks header boundaries
 with special characters.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../org/jnetpcap/nio/JMemory.html#toHexdump()">toHexdump</A></CODE> in class <CODE><A HREF="../../../org/jnetpcap/nio/JMemory.html" title="class in org.jnetpcap.nio">JMemory</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the string</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL>
<DD>Generates text formatted output using the default builtin formatter. The
 default is to generate TextFormatter that uses a StringBuilder for output
 buffer and gerate a single string that is returned from here.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>toString</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>formatted output of this packet</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/jnetpcap/packet/JMemoryPacket.JMemoryHeader.html" title="class in org.jnetpcap.packet"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/jnetpcap/packet/JPacket.State.html" title="class in org.jnetpcap.packet"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/jnetpcap/packet/JPacket.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="JPacket.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
